<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ritual Quiz â€” How Ritual-aligned are you?</title>
<style>
  :root{
    --bg-dark:#09120F;
    --bg-dark-2:#0D1814;
    --panel:#0F1D19;
    --accent:#0F5132;
    --accent-2:#146C43;
    --text:#E8F3F0;
    --muted:#BFDCD0;
    --correct:#29FFBF;
    --wrong:#FF6B6B;
  }

  /* Page layout */
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", system-ui, -apple-system, "Helvetica Neue", Arial;}
  body{
    background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-dark-2) 100%);
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow-y:auto;
    animation:bgShift 14s ease-in-out infinite alternate;
  }
  @keyframes bgShift {
    0% { filter: hue-rotate(0deg) brightness(1); }
    100% { filter: hue-rotate(5deg) brightness(1.02); }
  }

  .card {
    width:100%;
    max-width:780px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:18px;
    box-shadow: 0 20px 60px rgba(2,8,6,0.6);
    padding:28px;
    box-sizing:border-box;
    border:1px solid rgba(255,255,255,0.03);
  }

  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:14px;
  }
  .title{
    display:flex;
    gap:12px;
    align-items:center;
  }
  .logo {
    width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));
    display:flex;align-items:center;justify-content:center;font-weight:700;color:white;font-size:20px;
  }
  h1{margin:0;font-size:20px; color:var(--text);}
  p.lead{margin:6px 0 0 0;color:var(--muted);font-size:13px;}

  /* intro */
  .intro {
    text-align:center;
    padding:30px 10px 10px 10px;
    animation:introIn 2.2s cubic-bezier(.2,.9,.3,1) both;
  }
  @keyframes introIn {
    0% { opacity:0; transform: translateY(-18px) scale(.98); }
    100%{ opacity:1; transform: translateY(0) scale(1); }
  }
  #startBtn{
    margin-top:22px;
    background:var(--accent);
    color:var(--text);
    border:none;
    padding:14px 28px;
    border-radius:12px;
    font-size:16px;
    cursor:pointer;
    box-shadow: 0 10px 30px rgba(15,81,50,0.12);
    transition: transform .25s ease, box-shadow .25s ease, background .2s ease;
    animation: startBounce 3s ease-in-out infinite;
  }
  @keyframes startBounce {
    0%{ transform: translateY(0); }
    50%{ transform: translateY(-6px); }
    100%{ transform: translateY(0); }
  }
  #startBtn:hover{ transform: translateY(-3px) scale(1.02); background:var(--accent-2);}

  /* quiz area */
  .progressWrap { width:100%; height:12px; background: rgba(255,255,255,0.03); border-radius:12px; overflow:hidden; margin-bottom:16px; }
  .progress { height:100%; width:0%; background: linear-gradient(90deg,var(--accent),var(--accent-2)); transition: width .45s ease; }

  .questionBox { padding:12px 6px 0 6px; min-height:120px; display:flex; flex-direction:column; gap:10px; }
  .questionNumber { font-size:13px; color:var(--muted); }
  .questionText { font-size:18px; line-height:1.35; margin:6px 0; color:var(--text); transition:opacity .35s ease, transform .35s ease; }
  .options { display:flex; flex-direction:column; gap:10px; margin-top:8px; }

  .optionBtn{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));
    border:1px solid rgba(255,255,255,0.04);
    color:var(--text);
    padding:12px 14px;
    text-align:left;
    border-radius:10px;
    cursor:pointer;
    font-size:15px;
    transition: transform .18s ease, background .18s ease, box-shadow .18s ease;
    display:flex;
    gap:12px;
    align-items:center;
  }
  .optionBtn:hover { transform: translateY(-3px); box-shadow: 0 12px 30px rgba(2,8,6,0.18); background: rgba(255,255,255,0.02); }

  .optionLabel { flex:1; }
  .metaTag { font-size:12px; color:var(--muted); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); background: rgba(255,255,255,0.01); }

  /* feedback */
  .feedback { margin-top:12px; font-size:16px; color:var(--text); display:flex; align-items:center; justify-content:center; gap:10px; min-height:28px; }
  .emojiPop{ display:inline-block; transform:scale(0); animation:emojiPop .55s cubic-bezier(.2,.9,.3,1) forwards; }
  @keyframes emojiPop { 0%{ transform:scale(0); } 60%{ transform:scale(1.25);} 100%{ transform:scale(1);} }

  .correctStyle{ border-color: rgba(41,255,191,0.28); box-shadow: 0 8px 24px rgba(41,255,191,0.06); }
  .wrongStyle{ border-color: rgba(255,107,107,0.18); box-shadow: 0 8px 24px rgba(255,107,107,0.04); }

  /* next button */
  .controls { display:flex; gap:12px; align-items:center; justify-content:center; margin-top:18px; }
  .nextBtn {
    background:var(--accent);
    color:var(--text);
    border:none;
    padding:12px 22px;
    border-radius:10px;
    cursor:pointer;
    font-size:15px;
    transition: transform .18s ease, background .2s ease, box-shadow .18s ease;
    display:inline-flex;
    align-items:center;
    gap:10px;
  }
  .nextBtn:disabled { opacity:0.5; cursor:not-allowed; transform:none; }
  .nextBtn:hover:not(:disabled){ transform:translateY(-4px); background:var(--accent-2); box-shadow:0 12px 26px rgba(20,108,67,0.12); }

  /* final screen */
  .finalWrap { text-align:center; padding:12px; animation:finalIn 1.6s cubic-bezier(.2,.9,.3,1) both; }
  @keyframes finalIn { 0%{ opacity:0; transform: translateY(20px) scale(.98)} 100%{ opacity:1; transform:translateY(0) scale(1)} }
  .finalScore { font-size:20px; color:var(--text); }
  .finalEmoji { font-size:64px; margin-top:14px; transition: transform .8s cubic-bezier(.2,.9,.3,1); }
  .retakeBtn {
    margin-top:20px;
    background:transparent;
    color:var(--text);
    border:1px solid rgba(255,255,255,0.06);
    padding:12px 20px;
    border-radius:10px;
    cursor:pointer;
    transition: all .6s cubic-bezier(.2,.9,.3,1);
  }
  .retakeBtn:hover{ transform:translateY(-6px) scale(1.02); border-color: rgba(255,255,255,0.12); box-shadow: 0 18px 40px rgba(0,0,0,0.45); }

  footer.cred{ margin-top:18px; text-align:center; font-size:13px; color:var(--muted); }
  footer.cred a{ color:var(--accent); text-decoration:none; font-weight:600; }

  /* small screens tweaks */
  @media (max-width:520px){
    .card{ padding:18px; border-radius:14px; }
    h1{ font-size:18px; }
    .questionText{ font-size:16px; }
    .finalEmoji{ font-size:48px; }
  }
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Ritual Quiz">
    <header>
      <div class="title">
        <div class="logo">R</div>
        <div>
          <h1>Ritual Quiz</h1>
          <p class="lead">10 questions per round â€” 3 easy â€¢ 4 mid â€¢ 3 technical</p>
        </div>
      </div>
      <div class="metaTag">Built by <a href="https://x.com/THE_REAL_BIG4L?t=PYvu1HEe6mb-MVMpn7_3HQ&s=09" target="_blank" style="color:inherit;text-decoration:underline;">@THE_REAL_BIG4L</a></div>
    </header>

    <!-- Intro -->
    <section id="intro" class="intro">
      <div style="max-width:640px;margin:0 auto;">
        <p style="margin:6px 0 0 0;color:var(--muted);">Shuffle a fresh 10-question round each play. Youâ€™ll see immediate feedback per question and a final emoji score at the end.</p>
        <button id="startBtn" aria-label="Begin quiz">Click to Begin Quiz</button>
      </div>
      <footer class="cred">Questions sourced from Ritual docs (overview, symphony, resonance, modular storage, node specialization).</footer>
    </section>

    <!-- Quiz -->
    <section id="quizArea" style="display:none;">
      <div class="progressWrap" aria-hidden="true"><div class="progress" id="progressBar"></div></div>

      <div class="questionBox" aria-live="polite">
        <div class="questionNumber" id="qNumber">Q1 / 10</div>
        <div class="questionText" id="qText">Question text</div>
        <div class="options" id="options"></div>
        <div class="feedback" id="feedback" aria-atomic="true"></div>
      </div>

      <div class="controls">
        <button class="nextBtn" id="nextBtn" disabled>Next question</button>
      </div>

      <footer class="cred">Built by <a href="https://x.com/THE_REAL_BIG4L?t=PYvu1HEe6mb-MVMpn7_3HQ&s=09" target="_blank">@THE_REAL_BIG4L</a></footer>
    </section>

    <!-- Final -->
    <section id="finalArea" style="display:none;">
      <div class="finalWrap">
        <div class="finalScore" id="finalScore">You scored X / 10</div>
        <div class="finalEmoji" id="finalEmoji">ðŸ˜„</div>
        <button class="retakeBtn" id="retakeBtn">Retake Quiz</button>
      </div>
      <footer class="cred">Built by <a href="https://x.com/THE_REAL_BIG4L?t=PYvu1HEe6mb-MVMpn7_3HQ&s=09" target="_blank">@THE_REAL_BIG4L</a></footer>
    </section>
  </div>

<script>
/* -------------------------
   Full categorized question bank (66)
   24 Easy, 28 Mid, 14 Technical
   ------------------------- */

const easy = [
  { q:"What is Ritual primarily designed to bring on-chain?", options:["Scalable payments only","Enrich what users can do on-chain","Only storage","Simple token transfers"], answer:"Enrich what users can do on-chain" },
  { q:"Does Ritual aim to support AI workloads?", options:["Yes","No","Only off-chain","Only research"], answer:"Yes" },
  { q:"What term describes Ritual supporting different compute types like AI, ZK, TEE?", options:["Homogenous compute","Heterogeneous compute","Unified compute","Legacy compute"], answer:"Heterogeneous compute" },
  { q:"Which layer or system in Ritual coordinates heavy compute workloads like AI or ZK proofs?", options:["Symphony","EVM classic","PoW miner","Storage layer"], answer:"Symphony" },
  { q:"What is Modular Storage in Ritual?", options:["On-chain-only storage","Storage-agnostic system (Web2 or Web3)","Only S3 buckets","Only Arweave"], answer:"Storage-agnostic system (Web2 or Web3)" },
  { q:"Can Modular Storage use Web2 providers (like Hugging Face or S3)?", options:["Yes","No","Only Web3","Only local"], answer:"Yes" },
  { q:"Is EVM++ meant to improve developer compatibility with Ethereum tooling?", options:["Yes","No","Only for miners","Only for storage"], answer:"Yes" },
  { q:"What is the fee-market mechanism Ritual uses to match compute tasks with nodes?", options:["GasMarket","Resonance","FixedFee","AuctionX"], answer:"Resonance" },
  { q:"Do Scheduled Transactions let smart contracts schedule future calls without external keepers?", options:["Yes","No","Only off-chain bots","Only manual"], answer:"Yes" },
  { q:"Does Ritual try to avoid replicating heavy compute across all nodes?", options:["Yes","No","Only for storage","Only for tokens"], answer:"Yes" },
  { q:"Is model provenance (tracking model history) part of Ritual's goals?", options:["Yes","No","Only later","Not mentioned"], answer:"Yes" },
  { q:"Can Ritual act as a backend for other blockchains needing heavy compute?", options:["Yes","No","Only for storage","Only internal apps"], answer:"Yes" },
  { q:"Does Ritual support scheduling recurring or conditional transactions natively?", options:["Yes","No","Only cron jobs","Only off-chain"], answer:"Yes" },
  { q:"Is the goal of Ritual to allow new compute paradigms in Web3?", options:["No","Yes","Only tokens","Only storage"], answer:"Yes" },
  { q:"Which broad domains does Ritual target? (pick best)", options:["Only DeFi","AI + ZK + TEEs + cross-chain compute","Only NFTs","Only wallets"], answer:"AI + ZK + TEEs + cross-chain compute" },
  { q:"Does Ritual intend to be provable and verifiable for heavy compute results?", options:["Yes","No","Only trusted providers","Only off-chain verification"], answer:"Yes" },
  { q:"What is Node Specialization in one sentence?", options:["All nodes identical","Nodes optimized for specific workloads","No nodes allowed","Only storage nodes"], answer:"Nodes optimized for specific workloads" },
  { q:"Is the documentation referring to 'expressive blockchain' capabilities?", options:["Yes","No","Only once","Only tokens"], answer:"Yes" },
  { q:"Does Ritual allow developers to integrate AI inference into contracts?", options:["Yes","No","Only external","Only for testing"], answer:"Yes" },
  { q:"Is avoiding on-chain bloat for large model weights a purpose of Modular Storage?", options:["Yes","No","Only local","Only on-chain"], answer:"Yes" },
  { q:"Does Ritual seek to match user cost vs speed preferences when assigning compute?", options:["No","Yes","Only speed","Only cost"], answer:"Yes" },
  { q:"Are heterogeneous compute and storage patterns meant to be future-proof?", options:["Yes","No","Only current tech","Only legacy"], answer:"Yes" },
  { q:"Do Ritual docs discuss supporting multiple proof systems (proof-system-agnostic)?", options:["Yes","No","Only one system","Not mentioned"], answer:"Yes" },
  { q:"Is Ritual intended to lower the cost of heavy compute vs replicated chains?", options:["Yes","No","It increases cost","Not related"], answer:"Yes" }
];

const mid = [
  { q:"What problem does Symphony primarily solve for heavy workloads?", options:["Faster token transfers","Avoid full replicated execution; verify results instead","More storage","Cheaper block production"], answer:"Avoid full replicated execution; verify results instead" },
  { q:"Why is replicated execution inefficient for AI or ZK on classic chains?", options:["Too secure","All nodes re-execute heavy compute, wasting resources","Too cheap","Not compatible"], answer:"All nodes re-execute heavy compute, wasting resources" },
  { q:"How does Resonance help the compute pipeline?", options:["Fixes gas price","Matches requests to capable nodes based on cost/priority","Removes verification","Only schedules storage"], answer:"Matches requests to capable nodes based on cost/priority" },
  { q:"Which step ensures the right node type is selected for a compute job?", options:["Random selection","Resonance matching","Manual admin","Lowest gas only"], answer:"Resonance matching" },
  { q:"What does proof-based verification enable in Symphony?", options:["No security","Lightweight verification so other nodes don't re-execute fully","Centralization","Slower blocks"], answer:"Lightweight verification so other nodes don't re-execute fully" },
  { q:"Why is storage-agnostic design (Modular Storage) important for AI models?", options:["No reason","Avoids on-chain bloat and supports external backends","For fun","To complicate design"], answer:"Avoids on-chain bloat and supports external backends" },
  { q:"What advantage does node specialization provide?", options:["More replication","Specialized resources and efficiency for task types","Less security","No change"], answer:"Specialized resources and efficiency for task types" },
  { q:"How does Ritual handle model weights and large objects?", options:["Store them on chain always","Store them off-chain via Modular Storage backends","Delete them","Compress on chain"], answer:"Store them off-chain via Modular Storage backends" },
  { q:"Why use a fee-market like Resonance rather than fixed gas pricing for heterogeneous compute?", options:["No reason","Allows market pricing for heterogenous tasks and node capability matching","More expensive","Less transparent"], answer:"Allows market pricing for heterogenous tasks and node capability matching" },
  { q:"How do Scheduled Transactions change developer workflows?", options:["They don't","Allow natively scheduled/recurring contract calls without external keepers","Require bots","Only offline scheduling"], answer:"Allow natively scheduled/recurring contract calls without external keepers" },
  { q:"What does EVM++ provide for developers?", options:["Completely new language","Extensions to EVM so developers can adopt rapidly","Removes EVM","Only for validators"], answer:"Extensions to EVM so developers can adopt rapidly" },
  { q:"Why is model provenance valuable in decentralized AI?", options:["Not valuable","Tracks origin, lineage and IP for models ensuring trust","Just metadata","Slows everything"], answer:"Tracks origin, lineage and IP for models ensuring trust" },
  { q:"How can off-chain specialized execution be reconciled with on-chain determinism?", options:["It can't","Use proofs or attestations so results are verifiable on-chain","Ignore determinism","Use central authority"], answer:"Use proofs or attestations so results are verifiable on-chain" },
  { q:"What does 'execute once, verify many' mean in practice on Ritual?", options:["One node runs heavy compute; others verify via proofs instead of re-execution","Everyone executes once","No execution","Only verification"], answer:"One node runs heavy compute; others verify via proofs instead of re-execution" },
  { q:"How does Modular Storage improve uptime and resilience?", options:["It doesn't","By allowing multiple backends and redundancy across web2/web3 providers","Centralized backup","Always on chain"], answer:"By allowing multiple backends and redundancy across web2/web3 providers" },
  { q:"What are 'compute providers' in Ritual ecosystem?", options:["Only miners","Nodes or services offering specialized compute resources (AI, ZK, TEE)","Wallets","Block explorers"], answer:"Nodes or services offering specialized compute resources (AI, ZK, TEE)" },
  { q:"Why is heterogenous compute useful for future compute types?", options:["It isn't","It lets new proof systems and model types be integrated without redesigning the chain","Only for AI","Only for storage"], answer:"It lets new proof systems and model types be integrated without redesigning the chain" },
  { q:"How does Ritual reduce redundant computation costs for heavy workloads?", options:["By replicating more","By running on specialized nodes + proof verification instead of full replication","By increasing fees","By delaying execution"], answer:"By running on specialized nodes + proof verification instead of full replication" },
  { q:"What is a practical benefit of proof-system-agnostic verification?", options:["No benefit","Supports many verification methods so new compute types can be adopted","Only one proof type","Less security"], answer:"Supports many verification methods so new compute types can be adopted" },
  { q:"How does Resonance help prevent bottlenecks?", options:["It doesn't","By dynamically pricing and matching work to available node capacity","By forcing a single provider","By throttling users"], answer:"By dynamically pricing and matching work to available node capacity" },
  { q:"What does 'storage-agnostic' let developers change without rewriting apps?", options:["Nothing","Swap backend (web2/web3) while keeping same on-chain references or pointers","Always lock to one provider","Break apps"], answer:"Swap backend (web2/web3) while keeping same on-chain references or pointers" },
  { q:"What is a main risk Modular Storage mitigates for AI model hosting?", options:["Too much speed","On-chain bloat and single-vendor lock-in","Too many users","Low gas"], answer:"On-chain bloat and single-vendor lock-in" },
  { q:"Why is building native scheduling at protocol level preferred to relying on off-chain bots?", options:["It's not","Native scheduling is more reliable, permissionless and verifiable","Bots are faster","Bots are free"], answer:"Native scheduling is more reliable, permissionless and verifiable" },
  { q:"How does Ritual expect to help rollups and other chains?", options:["Not at all","By providing compute backend and prover services so other chains can outsource heavy work","By taking their users","By centralizing data"], answer:"By providing compute backend and prover services so other chains can outsource heavy work" },
  { q:"What is the verification frontier's role in Symphony?", options:["Not relevant","Defines where proofs/trust replace full re-execution to optimize performance","Incre
